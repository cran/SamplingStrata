<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>

<!-- MathJax scripts -->
<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML">
</script>


<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h1>Introduction</h1>

<p>Let us suppose we need to design a sample survey, having a complete frame containing information on the target population 
(identifiers plus auxiliary information). If our sample design is a stratified one, we need to choose how to form strata in 
the population, in order to get the maximum advantage by the available auxiliary information. In other words, we have to decide 
in which way to combine the values of the auxiliary variables (from now on, the &#39;X&#39; variables) in order to determine a new variable, 
called &#39;stratum&#39;. To do so, we have to take into consideration the target variables of our sample survey (from now on, the &#39;Y&#39; 
variables): if, to form strata, we choose the X variables most correlated to the Y&#39;s, the efficiency of the samples drawn by the 
resulting stratified frame may be greatly increased. In order to handle the whole auxiliary information in a homogenous way, we have 
to reduce continuous data to categorical (by mean of a k-means clustering technique, for example). Then, for every set of candidate 
auxiliary variables X&#39;s, we have to decide (i) what variables to consider as active variables in strata determination, and (ii) 
for each active variable, what set of values (in general, what aggregation of atomic values) have to be considered. 
Every combination of values of each active variable determine a particular stratification of the target population, i.e. 
a possible solution to the problem of &#39;best&#39; stratification. Here, by best stratification, we mean the stratification that ensures 
the minimum sample cost, sufficient to satisfy a set of precision constraints, set on the accuracy of the estimates of the survey target 
variables Y&#39;s (constraints expressed as maximum allowable sampling variance on estimates in different domains of interest).
When the cost of data collection is uniform over the strata, then the total cost is directly proportional to the overall sample size,
and the convenience of a particular stratification can be measured by the associated size of the sample, whose estimates 
are expected to satisfy given accuracy levels. This minimum size can be determined by applying the Bethel algorithm, with its Chromy 
variant. In general, the number of possible alternative stratifications for a given population may be very high, depending on 
the number of variables and on the number of their values, and in these cases it is not possible to enumerate them in order to assess 
the best one. A very convenient solution to this, is the adoption of the evolutionary approach, consisting in applying a 
genetic algorithm that may converge towards a near-optimal solution after a finite number of iterations. 
The methodology is fully described in @ballin:2013, and a complete illustration of the package, together with 
a comparison with the <em>stratification</em> package, is in @barcarol:2013.
Also a complete application in a case of network data is reported in @ballin:2016.
The implementation of the genetic algorithm is based on a modification of the functions in the <em>genalg</em> package [see @willighagen:2005].
In particular, the crossover operator ha been modified on the basis of the indications given by @oluing:2017.</p>

<h1>Procedural steps</h1>

<p>The optimization of the sampling design starts by making the sampling frame available, 
defining the target estimates of the 
survey and establishing the precision constraints on them. 
It is then possible to determine the best stratification and the 
optimal allocation. 
Finally, we proceed with the selection of the sample.
Formalizing, these are the required steps:</p>

<ul>
<li>  analysis of the frame data: identification of available auxiliary information;</li>
<li>  manipulation of auxiliary information: in case auxiliary variables are of the continuous type, they must be transformed into 
a categorical form;</li>
<li>  construction of atomic strata: on the basis of the categorical auxiliary variables available in the sampling frame, 
a set of strata can be constructed by calculating the Cartesian product of the values of all the auxiliary variables;</li>
<li>  characterization of each atomic stratum with the information related to the target variables: in order to optimise 
both strata and allocation of sampling units in strata, we need information on the distributions of the target variables 
(means and standard deviations) inside the different strata;</li>
<li>  choice of the precision constraints for each target estimate, possibly differentiated by domain;</li>
<li>  optimization of stratification and determination of required sample size and allocation in order to satisfy precision 
constraints on target estimates;</li>
<li>  analysis of the resulting optimized strata;</li>
<li>  association of new labels to sampling frame units, each of them indicating the new strata resulting by the optimal 
aggregation of the atomic strata;</li>
<li>  selection of units from the sampling frame with a \emph {stratified random sample} selection scheme;</li>
<li>evaluation of the found optimal solution in terms of expected precision and bias.</li>
</ul>

<p>In the following, we will illustrate each step starting from a real sampling frame, the one that comes with the R package <em>sampling</em>  (the dataframe <em>swissmunicipalities</em>).</p>

<h2>Analysis of the frame data and manipulation of auxiliary information</h2>

<p>As a first step, we have to define a frame dataframe containing the following information:</p>

<ul>
<li>  a unique identifier of the unit (no restriction on the name, may be &#39;cod&#39;);</li>
<li>  the values of m auxiliary variables (named from X1 to Xm);</li>
<li>  the (optional) values of p target variables (named from Y1 to Yp);</li>
<li>  the value of the domain of interest for which we want to produce estimates (named &#39;domainvalue&#39;).</li>
</ul>

<p>By typing the following statements in the R environment:</p>

<pre><code class="r">library(SamplingStrata)
#&gt; Loading required package: memoise
#&gt; Loading required package: doParallel
#&gt; Loading required package: foreach
#&gt; Loading required package: iterators
#&gt; Loading required package: parallel
#&gt; Loading required package: pbapply
#&gt; Loading required package: formattable
data(swissmunicipalities)
</code></pre>

<p>we get the <em>swissmunicipalities</em> dataframe, that contains 2896 observations (each observation refers to a Swiss municipality). 
Among the others, there are the following variables (data are referred to 2003):</p>

<ul>
<li>REG: Swiss region</li>
<li>Nom: municipality name</li>
<li>Surfacesbois: wood area</li>
<li>Surfacescult: area under cultivation</li>
<li>Alp: mountain pasture area</li>
<li>Airbat: area with buildings</li>
<li>Airind: industrial area</li>
<li>Pop020: number of men and women aged between 0 and 19</li>
<li>Pop2040: number of men and women aged between 20 and 39</li>
<li>Pop4065: number of men and women aged between 40 and 64</li>
<li>Pop65P: number of men and women aged between 65 and over</li>
<li>POPTOT: total population</li>
</ul>

<p>Let us suppose we want to plan a survey whose target estimates are the totals of population by age class in each Swiss region. 
In  this case, our Y variables will be:</p>

<ul>
<li>Y1: number of men and women aged between 0 and 19</li>
<li>Y2: number of men and women aged between 20 and 39</li>
<li>Y3: number of men and women aged between 40 and 64</li>
<li>Y4: number of men and women aged between 65 and over</li>
</ul>

<p>As for the auxiliary variables (X&#39;s), we can use all of those characterising the area use (wood, mountain or pasture, cultivated, industrial, with buildings). </p>

<p>Finally, we want to produce estimates not only for the whole country, but also for each one of the seven different regions.</p>

<p>Function <em>buildFrameDF</em> permits to organize data in a suitable mode for next processing:</p>

<pre><code class="r">swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissframe &lt;- buildFrameDF(df = swissmunicipalities,
                           id = &quot;id&quot;,
                           X = c(&quot;POPTOT&quot;,
                                 &quot;Surfacesbois&quot;,
                                 &quot;Surfacescult&quot;,
                                 &quot;Alp&quot;,
                                 &quot;Airbat&quot;,
                                 &quot;Airind&quot;),
                           Y = c(&quot;Pop020&quot;,
                                 &quot;Pop2040&quot;,
                                 &quot;Pop4065&quot;,
                                 &quot;Pop65P&quot;),
                           domainvalue = &quot;REG&quot;)
str(swissframe)
#&gt; &#39;data.frame&#39;:    2896 obs. of  12 variables:
#&gt;  $ id         : int  1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ X1         : int  363273 177964 166558 128634 124914 90483 72626 59496 48655 40377 ...
#&gt;  $ X2         : int  2326 67 97 1726 1635 2807 1139 408 976 425 ...
#&gt;  $ X3         : int  967 31 93 1041 714 1827 1222 183 196 694 ...
#&gt;  $ X4         : int  0 0 0 0 0 0 0 0 18 0 ...
#&gt;  $ X5         : int  2884 773 1023 1070 856 972 812 524 463 523 ...
#&gt;  $ X6         : int  260 60 213 212 64 238 134 27 108 137 ...
#&gt;  $ Y1         : int  57324 32429 28161 19399 24291 18942 14337 9533 9127 8128 ...
#&gt;  $ Y2         : int  131422 60074 50349 44263 44202 28958 24309 18843 14825 11265 ...
#&gt;  $ Y3         : int  108178 57063 53734 39397 35421 27696 21334 18177 15140 13301 ...
#&gt;  $ Y4         : int  66349 28398 34314 25575 21000 14887 12646 12943 9563 7683 ...
#&gt;  $ domainvalue: int  4 1 3 2 1 4 5 6 2 2 ...
</code></pre>

<p>As the X variables are of the continuous type, first we have to reduce them in a categorical (ordinal) 
form. </p>

<p>A suitable way to do so, is to apply a k-means clustering method [see @hartigan:1979] by using the function <em>var.bin</em>:</p>

<pre><code class="r">library(SamplingStrata)
swissframe$X1 &lt;- var.bin(swissmunicipalities$POPTOT, bins=18)
swissframe$X2 &lt;- var.bin(swissmunicipalities$Surfacesbois, bins=3)
swissframe$X3 &lt;- var.bin(swissmunicipalities$Surfacescult, bins=3)
swissframe$X4 &lt;- var.bin(swissmunicipalities$Alp, bins=3)
swissframe$X5 &lt;- var.bin(swissmunicipalities$Airbat, bins=3)
swissframe$X6 &lt;- var.bin(swissmunicipalities$Airind, bins=3)
</code></pre>

<p>Now, we have six different auxiliary variables of the categorical type, the first with 18 different modalities, the others 
with 3 modalities.</p>

<p>In any case, this dataframe comes with the package <em>SamplingStrata</em>: it can be made available by executing:</p>

<pre><code class="r">library(SamplingStrata)
data(swissframe)
head(swissframe)
#&gt;   progr REG X1 X2 X3 X4 X5 X6         id    Y1     Y2     Y3    Y4
#&gt; 1     1   4 18  3  2  1  3  3     Zurich 57324 131422 108178 66349
#&gt; 2     2   1 17  1  1  1  3  2     Geneve 32429  60074  57063 28398
#&gt; 3     3   3 17  1  1  1  3  3      Basel 28161  50349  53734 34314
#&gt; 4     4   2 17  2  3  1  3  3       Bern 19399  44263  39397 25575
#&gt; 5     5   1 17  2  2  1  3  2   Lausanne 24291  44202  35421 21000
#&gt; 6     6   4 16  3  3  1  3  3 Winterthur 18942  28958  27696 14887
#&gt;   domainvalue
#&gt; 1           4
#&gt; 2           1
#&gt; 3           3
#&gt; 4           2
#&gt; 5           1
#&gt; 6           4
</code></pre>

<p>We could also not indicate substantive X variables, if we want that each unit in the sampling frame be considered as an atomic stratum, and let to the optimization step to aggregate them on the basis of the values of the Y variable. 
In any case, as we have to indicate at least one X variable, we can use to this purpose the unique identifier in the frame:</p>

<pre><code class="r">swissmunicipalities$id &lt;- c(1:nrow(swissframe))
newframe &lt;- buildFrameDF(df = swissmunicipalities,
                         id = &quot;id&quot;,
                         X = &quot;id&quot;,
                         Y = c(&quot;Pop020&quot;,
                               &quot;Pop2040&quot;,
                               &quot;Pop4065&quot;,
                               &quot;Pop65P&quot;),
                         domainvalue = &quot;REG&quot;)
str(newframe)
#&gt; &#39;data.frame&#39;:    2896 obs. of  7 variables:
#&gt;  $ id         : int  1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ X1         : int  1 2 3 4 5 6 7 8 9 10 ...
#&gt;  $ Y1         : int  57324 32429 28161 19399 24291 18942 14337 9533 9127 8128 ...
#&gt;  $ Y2         : int  131422 60074 50349 44263 44202 28958 24309 18843 14825 11265 ...
#&gt;  $ Y3         : int  108178 57063 53734 39397 35421 27696 21334 18177 15140 13301 ...
#&gt;  $ Y4         : int  66349 28398 34314 25575 21000 14887 12646 12943 9563 7683 ...
#&gt;  $ domainvalue: int  4 1 3 2 1 4 5 6 2 2 ...
</code></pre>

<h2>Construction of atomic strata and association of the information related to target variables</h2>

<p>The <em>strata</em> dataframe reports information regarding each atomic stratum in the population. There is one row for each stratum. 
The total number of strata is given by the number of different combinations of X&#39;s values in the frame. 
For each stratum, the following information is required:</p>

<ul>
<li>  the identifier of the stratum (named &#39;stratum&#39; or &#39;strato&#39;), concatenation of the values of the X variables;</li>
<li>  the values of the m auxiliary variables (named from X1 to Xm) corresponding to those in the frame;</li>
<li>  the total number of units in the population (named &#39;N&#39;);</li>
<li>  a flag (named &#39;cens&#39;) indicating if the stratum is to be censused (=1) or sampled (=0);</li>
<li>  a variable indicating the cost of interviewing per unit in the stratum (named &#39;cost&#39;);</li>
<li>  for each target variable y, its mean and standard deviation, named respectively &#39;Mi&#39; and &#39;Si&#39;);</li>
<li>  the value of the domain of interest to which the stratum belongs (&#39;DOM1&#39;).</li>
</ul>

<p>For example:</p>

<pre><code class="r">data(strata)
head(strata)
#&gt;   stratum    N  X1  X2  X3       M1       M2       S1       S2 cens cost
#&gt; 1       1 2246 x11 x21 x31 148.1598 443.0137 95.41435 202.4569    0    1
#&gt; 2       2 2972 x11 x21 x32 184.2041 513.8995 81.26956 214.9999    0    1
#&gt; 3       3 1905 x11 x22 x31 193.8927 488.8046 79.66667 261.1876    0    1
#&gt; 4       4 3125 x11 x22 x32 181.3437 597.1925 82.77032 226.5086    0    1
#&gt; 5       5 1733 x12 x21 x31 109.9850 418.2234 88.20289 179.1571    0    1
#&gt; 6       6 1060 x12 x21 x32 114.7943 489.8292 52.71574 166.0292    0    1
#&gt;   DOM1
#&gt; 1  tot
#&gt; 2  tot
#&gt; 3  tot
#&gt; 4  tot
#&gt; 5  tot
#&gt; 6  tot
</code></pre>

<p>If in the <em>frame</em> dataframe are also present the values of the target Y variables (from a census, or from administrative data), 
it is possible to automatically generate the <em>strata</em> dataframe by invoking the <em>buildStrataDF</em> function.
Let us consider again the <em>swissframe</em> dataset that we have built in previous steps. 
To this dataset we can apply the function <em>buildStrataDF</em>:</p>

<pre><code class="r">  swissstrata &lt;- buildStrataDF(swissframe, progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  641
#&gt; ... of which with only one unit:  389
</code></pre>

<p>This is the structure of the created dataframe:</p>

<pre><code class="r">head(swissstrata)
#&gt;                  STRATO   N       M1        M2        M3       M4       S1
#&gt; 1*1*1*1*1*1 1*1*1*1*1*1 184 48.31522  49.40217  61.44022 28.40761 26.81536
#&gt; 1*1*1*1*1*2 1*1*1*1*1*2   1 98.00000 106.00000 116.00000 43.00000  0.00000
#&gt; 1*1*1*2*1*1 1*1*1*2*1*1   2 57.00000  64.00000  70.00000 50.00000  4.00000
#&gt; 1*1*2*1*1*1 1*1*2*1*1*1  11 77.72727  81.18182  92.36364 47.00000 15.24998
#&gt; 1*2*1*1*1*1 1*2*1*1*1*1   9 58.22222  61.55556  66.77778 36.22222 25.46360
#&gt; 1*2*1*2*1*1 1*2*1*2*1*1   8 61.00000  68.00000  84.62500 58.37500 24.56624
#&gt;                   S2       S3       S4 COST CENS DOM1 X1 X2 X3 X4 X5 X6
#&gt; 1*1*1*1*1*1 28.49831 32.63062 14.63922    1    0    1  1  1  1  1  1  1
#&gt; 1*1*1*1*1*2  0.00000  0.00000  0.00000    1    0    1  1  1  1  1  1  2
#&gt; 1*1*1*2*1*1  0.00000  1.00000 15.00000    1    0    1  1  1  1  2  1  1
#&gt; 1*1*2*1*1*1 18.69768 17.03084 11.12736    1    0    1  1  1  2  1  1  1
#&gt; 1*2*1*1*1*1 20.27100 24.89881 15.49751    1    0    1  1  2  1  1  1  1
#&gt; 1*2*1*2*1*1 19.48076 26.35307 26.55625    1    0    1  1  2  1  2  1  1
</code></pre>

<p>It is worth while noting that the total number of different atomic strata is 641, lower than the dimension of the Cartesian  product of the X&#39;s (which is 4374): this is due to the fact that not all combinations of the value of the auxiliary variables are present in the sampling frame.
Variables &#39;cost&#39; and &#39;cens&#39; are initialised respectively to 1 and 0 for all strata. It is possible to give them different values:</p>

<ul>
<li>  for variable &#39;cost&#39;, it is possible to differentiate the cost of interviewing per unit by assigning real values;</li>
<li>  for variable &#39;cens&#39;, it is possible to set it equal to 1 for all strata that are of the &#39;take-all&#39; type (i.e. all units in that strata must be selected).</li>
</ul>

<p>The <em>swissstrata</em> dataframe comes together with <em>SamplingStrata</em> package, it can be made available by typing:</p>

<pre><code class="r">data(swissstrata)
</code></pre>

<p>On the contrary, if there is no information in the frame regarding the target variables, it is necessary to build the strata 
dataframe starting from other sources, for instance a previous round of the same survey, or from other surveys.
In this case, we need to read sample data by executing:</p>

<pre><code class="r">samp &lt;- read.delim(&quot;samplePrev.txt&quot;)
</code></pre>

<p>The only difference is that computed mean and variances of the Y&#39;s are sampling estimates, whose reliability should be evaluated 
by carefully considering their sampling variances. In addition to the naming constraints previously introduced, this case requires 
that a variable named &#39;WEIGHT&#39; is present in the samp dataframe.
Then we can execute this function in this way:</p>

<pre><code class="r">strata &lt;- buildStrataDF(samp)
</code></pre>

<p>The result is much the same than in the previous case: the function creates a new dataframe, <em>strata</em>, and writes out in the working 
directory the strata file, named &#39;strata.txt&#39;.</p>

<h2>Choice of the precision constraints for each target estimate</h2>

<p>The <em>errors</em> dataframe contains the accuracy constraints that are set on target estimates. 
This means to define a maximum coefficient of variation for each variable and for each domain value. 
Each row of this frame is related to accuracy constraints in a particular subdomain of interest, identified by the <em>domainvalue</em> value.
In the case of the Swiss municipalities, we have chosen to define the following constraints:</p>

<pre><code class="r">data(swisserrors)
swisserrors
#&gt;    DOM  CV1  CV2  CV3  CV4 domainvalue
#&gt; 1 DOM1 0.08 0.12 0.08 0.12           1
#&gt; 2 DOM1 0.08 0.12 0.08 0.12           2
#&gt; 3 DOM1 0.08 0.12 0.08 0.12           3
#&gt; 4 DOM1 0.08 0.12 0.08 0.12           4
#&gt; 5 DOM1 0.08 0.12 0.08 0.12           5
#&gt; 6 DOM1 0.08 0.12 0.08 0.12           6
#&gt; 7 DOM1 0.08 0.12 0.08 0.12           7
</code></pre>

<p>This example reports accuracy constraints on variables Y1, Y2, Y3 and Y4 that are the same for all the 7 different subdomains 
(Swiss regions) of domain level DOM1. Of course we can differentiate the precision constraints region by region. 
It is important to underline that the values of &#39;domainvalue&#39; are the same than those in the <em>frame</em> dataframe, and correspond 
to the values of variable &#39;DOM1&#39; in the strata dataframe.
Once having defined dataframes containing frame data, strata information and precision constraints, it is worth while to check
their internal and reciprocal coherence. It is possible to do that by using the function <em>checkInput</em>:</p>

<pre><code class="r">checkInput(errors = checkInput(errors = swisserrors, 
                               strata = swissstrata, 
                               sampframe = swissframe))
#&gt; 
#&gt; Input data have been checked and are compliant with requirements
#&gt; 
#&gt; No input data indicated
</code></pre>

<p>For instance, this function controls that the number of auxiliary variables is the same in the <em>frame</em> and in the 
<em>strata</em> dataframes; 
that the number of target variables indicated in the <em>frame</em> dataframe is the same than the number of means and standard deviations in
the <em>strata</em> dataframe, and the same than the number of coefficient of variations indicated in the <em>errors</em> dataframe.</p>

<p>If we try to determine the total size of the sample required to satisfy these precision constraints, considering the current 
stratification of the frame (the 641 atomic strata), we can do it by simply using the function  <em>bethel</em>. 
This function requires a slightly different specification of the constraints dataframe:</p>

<pre><code class="r">cv &lt;- swisserrors[1,]
cv
#&gt;    DOM  CV1  CV2  CV3  CV4 domainvalue
#&gt; 1 DOM1 0.08 0.12 0.08 0.12           1
</code></pre>

<p>because the <em>bethel</em> function does not permit to differentiate precision constraints by subdomain. 
In any case, the result of the application of the Bethel algorithm [see bethel:1989] is:</p>

<pre><code class="r">allocation &lt;- bethel(swissstrata,cv)
sum(allocation)
#&gt; [1] 893
</code></pre>

<p>That is, the required amount of units to be selected, with no optimization of sampling strata. 
In general, after the optimization, this number is sensibly reduced.</p>

<h2>Optimization of frame stratification</h2>

<p>Once the strata and the constraints dataframes have been prepared, it is possible to apply the function that optimises the 
stratification of the frame, that is <em>optimizeStrata</em>. This function operates on all subdomains, identifying the best solution 
for each one of them.
The fundamental parameters to be passed to optimizeStrata are:</p>

<ul>
<li>  <em>errors</em>: the (mandatory) dataframe containing the precision levels expressed in terms of maximum allowable 
coefficients of variation that regard the estimates on target variables of the survey;</li>
<li>  <em>strata</em>: the (mandatory) dataframe containing the information related to &#39;atomic&#39; strata, i.e. the strata obtained by the 
Cartesian product of all auxiliary variables X&#39;s. Information concerns the identifiability of strata (values of X&#39;s) and variability 
of Y&#39;s (for each Y, mean and standard deviation in strata); </li>
<li>  <em>cens</em>: the (optional) dataframe containing the &#39;take-all&#39; strata, those strata whose units must be selected in whatever sample. 
It has same structure than *strata} dataframe; </li>
<li>  <em>strcens</em>: flag (TRUE/FALSE) to indicate if &#39;take-all&#39; strata do exist or not. Default is FALSE; </li>
<li>  <em>initialStrata</em>: the initial limit on the number of strata for each solution. Default is NA, and in this case it is set equal to the number of atomic strata in each domain. If the parameter <em>addStrataFactor</em> is equal to zero, then <em>initialStrata</em> is equivalent to the maximum number of strata to be obtained in the final solution; </li>
<li>  <em>addStrataFactor</em>: indicates the probability that at each mutation the number of strata may increase with respect 
to the current value. Default is 0.0;</li>
<li>  <em>minnumstr</em>: indicates the minimum number of units that must be allocated in each stratum. Default is 2;</li>
<li><em>iter</em>: indicates the maximum number of iterations (= generations) of the genetic algorithm. Default is 50</li>
<li><em>pops</em>: dimension of each generations in terms of number 0f individuals to be generated. Default is 20;</li>
<li>  <em>mut_chance</em> (mutation chance): for each new individual, the probability to change each single chromosome, i.e. one bit of the 
solution vector. High values of this parameter allow a deeper exploration of the solution space, but a slower convergence, while low 
values permit a faster convergence, but the final solution can be distant from the optimal one. Default is NA, in correspondence of which it is computed as 1/(vars+1) where vars is the length of elements in the solution;</li>
<li>  <em>elitism_rate</em>: indicates the rate of better solutions that must be preserved from one generation to another. Default is 0.2;</li>
<li>  <em>suggestions</em>: indicates one possible solution (from kmeans clustering or from previous runs) that will be introduced in the initial population. Default is NULL;</li>
<li>  <em>realAllocation</em> : if FALSE, the allocation is based on INTEGER values; if TRUE, the allocation is based on REAL values. Default is TRUE;</li>
<li>  <em>writeFiles</em> : indicates if the various dataframes and plots produced during the execution have to be written in the working directory /output. Default is FALSE;</li>
<li><em>showPlot</em> : indicates if the plot showing the trend in the value of the objective function has to be shown or not. In parallel = TRUE, this defaults to FALSE, otherwise default is TRUE.</li>
<li>  <em>parallel</em> :  Should the analysis be run in parallel. Default is TRUE</li>
<li>  <em>cores</em> : if the analysis is run in parallel, how many cores should be used. If not specified n-1 of total available cores are used OR if number of domains &lt; (n-1) cores, then number of cores equal to number of domains are used</li>
</ul>

<p>In the case of the Swiss municipalities, we can use almost all of default values for parameters with the exception of the errors and strata dataframes, and for the option &#39;writeFiles&#39;:</p>

<pre><code class="r">solution1 &lt;- optimizeStrata(
    errors = swisserrors, 
    strata = swissstrata,
    parallel = TRUE,
    writeFiles = FALSE,
    showPlot = FALSE)
</code></pre>

<p>Note that by so doing the <em>initialStrata</em> parameter is set equal to the number of atomic strata in each domain . Another possibility is to set a
pre-determined value for each domain, for instance equal in each domain, as c(5,5,5,5,5,5,5,5).</p>

<p>The execution of <em>optimizeStrata</em> produces the solution of 7 different optimization problems, one for each domain.</p>

<p><img src="data:image/png;base64,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" title="plot of chunk unnamed-chunk-18" alt="plot of chunk unnamed-chunk-18" width="600px" /></p>

<p>The graphs (we report here the one related to domain 3) illustrate the convergence of the solution to the final one starting from the initial one (i.e. the one related to the atomic strata). Along the x-axis are reported the executed iterations, from 1 to the maximum, while on the y-axis are reported the size of the sample required to satisfy precision constraints. The upper (red) line represent the average sample size for each iteration, while the lower (black) line represents the best solution found until the i-th iteration.</p>

<p>The results of the execution are contained in the list &#39;solution&#39;, composed by two elements:</p>

<ol>
<li> <em>solution1$indices</em>: the vector of the indices that indicates to what aggregated stratum each atomic stratum belongs;</li>
<li> <em>solution1$aggr_strata</em>: the dataframe containing information on the optimal aggregated strata. </li>
</ol>

<p>We can calculate the expected CV&#39;s by executing the function:</p>

<pre><code class="r">expected_CV(solution1$aggr_strata)
#&gt;      cv(Y1) cv(Y2) cv(Y3) cv(Y4)
#&gt; DOM1  0.077  0.077  0.073  0.075
#&gt; DOM2  0.070  0.074  0.076  0.086
#&gt; DOM3  0.078  0.079  0.078  0.084
#&gt; DOM4  0.078  0.075  0.077  0.072
#&gt; DOM5  0.078  0.078  0.078  0.078
#&gt; DOM6  0.080  0.079  0.080  0.073
#&gt; DOM7  0.074  0.078  0.072  0.085
</code></pre>

<p>and compare them to the set of precision constraints in order to verify the compliance:</p>

<pre><code class="r">swisserrors
#&gt;    DOM  CV1  CV2  CV3  CV4 domainvalue
#&gt; 1 DOM1 0.08 0.12 0.08 0.12           1
#&gt; 2 DOM1 0.08 0.12 0.08 0.12           2
#&gt; 3 DOM1 0.08 0.12 0.08 0.12           3
#&gt; 4 DOM1 0.08 0.12 0.08 0.12           4
#&gt; 5 DOM1 0.08 0.12 0.08 0.12           5
#&gt; 6 DOM1 0.08 0.12 0.08 0.12           6
#&gt; 7 DOM1 0.08 0.12 0.08 0.12           7
</code></pre>

<h1>Initial solution with kmeans clustering of atomic strata</h1>

<p>In order to speed up the convergence towards the optimal solution, an initial one can be given as a &ldquo;suggestion&rdquo; to &#39;optimizeStrata&#39; function. The function <em>KmeansSolution</em> produces this initial solution by clustering atomic strata considering the values of the means of all the target variables Y. </p>

<p>Also, the optimal number of clusters is determined inside each domain.
If the default value for nstrata is used, then the number of aggregate strata is optimized by varying the number of cluster from 2 to number of atomic strata in each domain, divided by 2. Otherwise, it is possible to indicate a fixed number of aggregate strata to be obtained.</p>

<p>Other parameters are: </p>

<ul>
<li>  <em>minnumstrat</em>: the minimum number of units to be allocated in each stratum(default is 2);</li>
<li>  <em>maxcluster</em>: the maximum number of clusters to be considered in the execution of kmeans algorithm;</li>
<li>  <em>showPlot</em>: if TRUE, allows to visualise the optimization.</li>
</ul>

<p>For any given number of clusters, the correspondent aggregation of atomic 
strata is considered as input to the function &#39;bethel&#39;. The number of clusters
for which the value of the sample size necessary to fulfil precision constraints
is the minimum one, is retained as the optimal one.</p>

<p>The overall solution is obtained by concatenating optimal clusters obtained in domains. The result is a dataframe with two columns: the first indicates the clusters, the second the domains:</p>

<pre><code class="r">solutionKmeans1 &lt;- KmeansSolution(swissstrata,
                                   swisserrors,
                                   nstrata=NA,
                                   minnumstrat=2,
                                   maxclusters=NA,
                                   showPlot=FALSE)
#&gt; 
#&gt; -----------------
#&gt;  Kmeans solution 
#&gt; -----------------
#&gt;  *** Domain:  1  ***
#&gt;  Number of strata:  9
#&gt;  Sample size     :  18
#&gt;  *** Domain:  2  ***
#&gt;  Number of strata:  8
#&gt;  Sample size     :  18
#&gt;  *** Domain:  3  ***
#&gt;  Number of strata:  8
#&gt;  Sample size     :  15
#&gt;  *** Domain:  4  ***
#&gt;  Number of strata:  6
#&gt;  Sample size     :  10
#&gt;  *** Domain:  5  ***
#&gt;  Number of strata:  7
#&gt;  Sample size     :  13
#&gt;  *** Domain:  6  ***
#&gt;  Number of strata:  7
#&gt;  Sample size     :  13
#&gt;  *** Domain:  7  ***
#&gt;  Number of strata:  8
#&gt;  Sample size     :  16
head(solutionKmeans1)
#&gt;   suggestions domainvalue
#&gt; 1           8           1
#&gt; 2           8           1
#&gt; 3           8           1
#&gt; 4           8           1
#&gt; 5           8           1
#&gt; 6           8           1
</code></pre>

<p>This solution can be given as argument to the parameter <em>suggestion</em> in the <em>optimizeStrata</em> function:</p>

<pre><code class="r">solution_with_kmeans &lt;- optimizeStrata(
    errors = swisserrors,
    strata = swissstrata,
    suggestions = solutionKmeans1,
    parallel = TRUE,
    writeFiles = TRUE,
    showPlot = FALSE)
</code></pre>

<pre><code class="r">sum(ceiling(solution_with_kmeans$aggr_strata$SOLUZ))
#&gt; [1] 101
</code></pre>

<p>thus obtaining a much more convenient solution than the one without the kmeans suggestion, with the same number of iterations.</p>

<h1>Adjustment of the final sampling size</h1>

<p>After the optimization step, the final sample size is the result of the allocation of units in final strata. This allocation is such that the precision constraints are expected to be satisfied. 
Actually, three possible situations may occur:</p>

<ul>
<li>  the resulting sample size is acceptable;</li>
<li>  the resulting sample size is to high, it is not affordable with respect to the available budget;</li>
<li>the resulting sample size is too low, the available budget permits to increase the number of units.</li>
</ul>

<p>In the first case, no action is required.
In the second case, it is necessary to reduce the number of units, by equally applying the same reduction rate in each stratum.
In the third case, we could either to set more tight precision constraints, or proceed to increase the sample size by applying the same increase rate in each stratum.
This increase/reduction process is iterative, as by applying the same rate we could find that in some strata there are not enough units to increase or to reduce.
The function <em>adjustSize</em> permits to obtain the desired final sample size.
Let us suppose that the obtained sample size is not affordable. We can reduce it by executing the following code:</p>

<pre><code class="r">adjustedStrata &lt;- adjustSize(size=150,strata=solution1$aggr_strata,cens=NULL)
#&gt; 
#&gt;  210
#&gt;  198
#&gt;  192
#&gt;  192
#&gt;  Final adjusted size:  192
sum(adjustedStrata$SOLUZ)
#&gt; [1] 192
</code></pre>

<p>Instead, if we want to increase the size because the budget allows to do this, then this is the code:</p>

<pre><code class="r">adjustedStrata &lt;- adjustSize(size=250,strata=solution1$aggr_strata,cens=NULL)
#&gt; 
#&gt;  270
#&gt;  268
#&gt;  268
#&gt;  Final adjusted size:  268
sum(adjustedStrata$SOLUZ)
#&gt; [1] 268
</code></pre>

<p>The difference between the desired sample size and the actual adjusted size depends on the number of strata in the optimized solution. Consider that the adjustment is performed in each stratum by taking into account the relative difference between the current sample size and the desired one: this produces an allocation that is expressed by a real number, that must be rounded. The higher the number of strata, the higher the impact of the rounding in all strata on the final adjusted  sample size.</p>

<h1>Analysis of results</h1>

<p>This function has two purposes:</p>

<ol>
<li>instrumental to the processing of the sampling frame (attribution of the labels of the optimized strata to the population units);</li>
<li>analysis of the aggregation of the atomic strata obtained in the optimized solution.</li>
</ol>

<p>The function <em>updateStrata</em> assigns the labels of the new strata to the initial one in the dataframe <em>strata</em>, and produces:</p>

<ul>
<li>a new dataframe named <em>newstrata</em> containing all the information in the <em>strata</em> dataframe, plus the labels of the new optimized strata;</li>
<li>a table, contained in the dataset <em>strata_aggregation.txt</em>, showing in which way each optimized stratum aggregates the auxiliary variables X&#39;s.</li>
</ul>

<p>The function is invoked in this way:</p>

<pre><code class="r">newstrata &lt;- updateStrata(swissstrata, 
                          solution1, 
                          writeFiles = TRUE)
</code></pre>

<p>Now, the atomic strata are associated to the aggregate strata defined in the optimal solution, by means of the variable <em>LABEL</em>. If we want to analyse in detail the new structure of the stratification, we can look at the <em>strata_aggregation.txt</em> 
file:</p>

<pre><code class="r">strata_aggregation &lt;- read.delim(&quot;strata_aggregation.txt&quot;)
head(strata_aggregation)
#&gt;   DOM1 AGGR_STRATUM X1 X2 X3 X4 X5 X6
#&gt; 1    1            1  1  1  1  1  1  1
#&gt; 2    1            1  1  1  1  1  1  2
#&gt; 3    1            1  1  3  1  2  1  1
#&gt; 4    1            1  3  1  1  1  1  2
#&gt; 5    1            2  1  1  1  2  1  1
#&gt; 6    1            2  3  2  1  1  1  1
</code></pre>

<p>In this structure, for each aggregate stratum the values of the X&#39;s variables in each contributing atomic stratum 
are reported. It is then possible to understand the meaning of each aggregate stratum produced by the optimization.</p>

<h1>Updating the frame and selecting the sample</h1>

<p>Once the optimal stratification has been obtained, to be operational we need to accomplish the following two steps:</p>

<ul>
<li>  to update the frame units with new stratum labels (combination of the new values of the auxiliary variables X&#39;s);</li>
<li>  to select the sample from the frame.</li>
</ul>

<p>As for the first, we execute the following command:</p>

<pre><code class="r">framenew &lt;- updateFrame(swissframe, newstrata, writeFiles=FALSE)
</code></pre>

<p>The function <em>updateFrame</em> receives as arguments the indication of the dataframe in which the frame information is memorised, 
and of the dataframe produced by the execution of the <em>updateStrata</em> function.
The execution of this function produces a dataframe <em>framenew</em>, and also a file (named <em>framenew.txt</em>) with the labels of the new 
strata produced by the optimisation step.
The allocation of units is contained in the <em>SOLUZ</em> column of the dataset <em>outstrata.txt</em>. At this point it is possible to select the 
sample from the new version of the frame:</p>

<pre><code class="r">sample &lt;- selectSample(framenew, solution1$aggr_strata, writeFiles=FALSE)
#&gt; 
#&gt; *** Sample has been drawn successfully ***
#&gt;  332  units have been selected from  100  strata
#&gt; 
#&gt; ==&gt; There have been  20  take-all strata 
#&gt; from which have been selected  58 units
</code></pre>

<p>that produces two .csv files:</p>

<ul>
<li>  <em>sample.csv</em> containing the units of the frame that have been selected, together with the weight that has been calculated 
for each one of them;</li>
<li>  <em>sample.chk.csv</em> containing information on the selection: for each stratum, the number of units in the population, 
the planned sample, the number of selected units, the sum of their weights that must equalise the number of units in the population.</li>
</ul>

<p>The <em>selectSample</em> operates by drawing a simple random sampling in each stratum.</p>

<p>A variant of this function is <em>selectSampleSystematic</em>. The only difference is in the method used for selecting units in each strata, that is by executing the following steps:</p>

<ol>
<li> a selection interval is determined by considering the inverse of the
sampling rate in the stratum;</li>
<li> a starting point is determined by selecting a value in this interval;</li>
<li>the selection proceeds by selecting as first unit the one corresponding
to the above value, and then selecting all the units individuated by adding the 
selection interval.</li>
</ol>

<p>This selection method can be useful if associated to a particular ordering of the selection
frame, where the ordering variable(s) can be considered as additional 
stratum variable(s). For instance, we could decide that it could be important 
to consider the overall population in municipalities when selecting units.
Here is the code:</p>

<pre><code class="r"># adding POPTOT to framenew
data(&quot;swissmunicipalities&quot;)
framenew &lt;- merge(framenew,swissmunicipalities[,c(&quot;REG&quot;,&quot;Nom&quot;,&quot;POPTOT&quot;)],
                  by.x=c(&quot;REG&quot;,&quot;ID&quot;),by.y=c(&quot;REG&quot;,&quot;Nom&quot;))
# selection of sample with systematic method
sample &lt;- selectSampleSystematic(frame=framenew,
                                 outstrata=solution1$aggr_strata,
                                 sortvariable = c(&quot;POPTOT&quot;))
#&gt; 
#&gt; *** Sample has been drawn successfully ***
#&gt;  332  units have been selected from  100  strata
#&gt; 
#&gt; ==&gt; There have been  20  take-all strata 
#&gt; from which have been selected  58 units
head(sample,3)
#&gt;   DOMAINVALUE STRATO REG          ID      STRATUM PROGR X1 X2 X3 X4 X5 X6
#&gt; 1           1      1   1 Constantine  1*1*1*1*1*1  2302  1  1  1  1  1  1
#&gt; 2           1      1   1       Syens  1*1*1*1*1*1  2698  1  1  1  1  1  1
#&gt; 3           1     10   1     Monthey 12*2*1*1*2*3    75 12  2  1  1  2  3
#&gt;     Y1   Y2   Y3   Y4 LABEL POPTOT WEIGHTS        FPC
#&gt; 1   70   75   87   48     1    280    93.5 0.01069519
#&gt; 2   24   34   44   15     1    117    93.5 0.01069519
#&gt; 3 3359 4170 4509 1895    10  13933     1.0 1.00000000
</code></pre>

<h1>Evaluation of the found solution</h1>

<p>In order to be confident about the quality of the found solution, the function <em>evalSolution</em> allows to 
run a simulation, based on the selection of a desired number of samples from the frame to which the stratification, identified
as the best, has been applied.
The user can invoke this function also indicating the number of samples to be drawn:</p>

<pre><code class="r">eval &lt;- evalSolution(framenew, 
                     solution1$aggr_strata, 
                     nsampl=100, 
                     writeFiles=FALSE,
                     progress=FALSE) 
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-31"/><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAfgAAAH4CAMAAACR9g9NAAAAnFBMVEUAAAAAADoAAGYAOjoAOmYAOpAAZpAAZrY6AAA6ADo6AGY6OmY6OpA6ZrY6kJA6kNtmAABmADpmAGZmOgBmOpBmZjpmZmZmtrZmtv+QOgCQOjqQOmaQkGaQtpCQ27aQ29uQ2/+2ZgC2Zjq2tma225C2/7a2///bkDrbtmbb25Db/7bb/9vb////pQD/tmb/25D/29v//7b//9v///+bjQfvAAAACXBIWXMAAAsSAAALEgHS3X78AAAS9UlEQVR4nO2djXbjthGF6U23dpJt5d2kib1pEqlNV23iSpX4/u9WAvwRaVMjEMCQM5x7z56zNkdzCeAzCJAiyKKETKpYugDQMgJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4owJ4o1oG/OmxcHpyP737ctm+e+o+8O7L+bkf6j4wzBjX8aG4247t9tXOrnt1O7/2kZHtleFYmbuE9y9koUMqlk+Lgi82w8274qn320gjDj9wXVc+N2ha2osgSO00Bfy8Wgq8a59D8e6L/6nqoIXr4dWfwv35+e5vxd0vdY//Z1FUreVbs2q3P/wH6tx9/WdTf6Zr7HqrN/KtXJtt/fb28HKofr7bnjuvXXFfOmr3ZfuxsmyNK5NeTtkUtKtCf+9t6d/99lBv6Zn54I8efFPuQ/Hn5+pje/+Rxn3o2NsVi5YE7/qI+6nu/w3Xmtrvj80fgmv8EfA7H7ovm8/c17bN1j54/9OuOby82ZnbcKjxVi3ffqxsM11uL+el/b+tQn/v50vp/ZZRs67ch6JV373n2N8VixYFv6/BHx+aCtYHS9dsTSNsPJEW/Iv/QJ3he4jvuJvy0DRQt7U7jNdm3t+ZtIf65m/nqdlNleAsuo81mfXO+zldQcteCdu9t6Xf+P0NzI4P1f97v4umhO5gV/XpJ1/axm3g2N8ViySA93/dbkPddK4pLpO7attb8Affy/Yu5FuybqRuaw+8M2u6VwvR7a4HvkrY+F+6j9WZzc77OV1By/LyN9ON3V3p3ZaB2aH+W3ZbmxIefKduHDr3nmN/VyyScKj341nRdNSp4NtQGQje72sAvkr/vR3Ix8F3OW1By14JX4FvtgSBd6PY3bZ1Hzr2dsUiEZM7p13Dqw++O9RX2/fF+KG+1/Rjh/p6Stagcal7fyzugy93d393g/Hg6Do41Hc5bUHLm+AHZmOH+gv41n3ckUtLn8696oR+Vr8dTJ26KVH9w+vJ3bChuplVH3yXXx8sejurwbdn/d1uyleTuzanK2g5Dt7P6ruD04hZb3J3Ad+6Dxz7u2KRiAs4rpbN2VI13e4d6uszKv/xH5vjX31Y7p3O9Zq+3foavG/v9tSs+nnjhoOLV30ud/lYndk/nevltIfft+Dr0ndbemae/F+Hp3MX8K3720M945Eel2ytCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNCuCNKgV8AUkWI/iEXIhbAG9UAG9UAG9UAG9UAG9UAG9UAG9UAG9UAG9UAG9UyeDrx/CMPYcH4CUrFfz5uX6O0OHtkxangM/yxQI0QangT5++DP6fkpu4ayhFQnp8zK6hFCWP8c0z6fKP8QDPKrmzeoBnlVzwEKtwOmdUcid3EKtwOmdUcns8wLMKp3NGJXdWD/CsAnijYjidw1cqGiR3cgexSu7pHMQquT0efzeswumcUWFWb1QAb1S5wONavTLJ7fFQT/lvRgV4reI9oOJGDLFaGDzO45fSwuBxI8ZSQo+HYoQrd0Yld1YP8KySCx6itfTpHE8udFMAb1SrBY+/G1oAb1QAL0H6nugB8FwSXn6A55Lw8ssFn1ULHIq5q7/aMZ5bwsFw+wO8Vq0WvPAes7gAXqg/twBeqISXH+C5JLz8AM8l4eWXC55b2ucQqx3juSUcDLc/wGvVasEL7zGLa2nwx4fibqvxvnqAT3J399WfnzcKwXNLePlTwdfAd/cA/1rCy5+jx1faf/UNwA8lvPzJY/zpceP+279dSqO75mv3lzur55ZwMNz+AC9OgXcLJd5UlON0zknfokm54P+bUWzg9S6TBniyELdKiQcjXFN0+XWA19vjubVy8HgwwjWtHTxP7gwSO4cAeF4BfFrp1T7nTmzxdIDXO7kDeLIQt0o5cjqXaSUawIsGr7fHc2vtYzxO565o7eB5ctPTFxfAC5XYOYQu8PpePwbwLKVPzJ1BYotnHbzYHsktJeBxI0Zu6QCP8/hrWvkYjxsxrmnl4NHjr2nl4Pmu3HFL7BxCCXie3BkE8CylT8ydQWKLpwn8fhOfm7hrsf7RAnheATxZiLCyTgI/zxKhxYUxfpmKLS6An7tiQo4oAD93xYQcUQB+7ooBfEj5AX6yP7cAPrJiAB9SfoCf7M8tgI+smBDwGOPnrhjAh5Qf4Cf7J1b/duIs5Qf4yf6J1b+dOEv5AX6yf2L1byfOUn6An+zPLYCPrBjAh5Qf4Cf7cwvgIysmBDzG+LkrBvAh5Qf4yf6J1b+dOEv5AX6yf2L1byfOUv484I9v308B8NGJs5Q/FXyzkGZsKY1x8NHSAb4iXyFHj88oJeAd+vf/Afh8UgPePRxhZM2kdfArH+MjcgH+RuIs5Qf46f7M9+0rAT/9GTjqwSv3p+mEhaOeiKG94bT703TCwlHPwNHecNr9aTphYfR4hf40nbBwGfMMHO0Np92fphMWjsrV3nDa/Wk6YeGoXO0Np92fphMWLnE6p8+fphMWxuSOw5/5AhFNJywc9TIi9WC4/VWAR4/P768CPE7n1PnTdMLCUbnaG067P00nLByVq73htPvTdMLCF+FavRp/mk5YOCpXe8Np96fphIWjcrU3nHZ/mk5YuMSVO33+NJ2wMM7jFfrTdMLCuBFDoT9NJyyMHq/Qn6YTFi5x5U6fP00nLByVq73htPvTdMLCUbnaG067P00nLNxq2qtJmCsGf9qfphMWbgXwivxpOmHhVgCvyJ+mExaOytXecNr9aTph4ahc7Q2n3Z+mMwzv37/si+KJ/myotfaG0+5P0xmETx+31b/R553czJ2/YvCn/Wk6g/Dp05eqzwP8OvxpOsPwvrjbHnCoX4c/TScsHJWrveG0+9N0wsJRudobTrs/TWcY3l/7Bi4gd/aKwZ/2p+kMwtWU/nBf7u/pz4Zaa2847f40nUG4mtXX/+gPB1prbzjt/jSdQfj8eVv9w+ncOvxpOsNwxfxQFGPfxNzOnb1i8Kf9aTph4ahc7Q2n3Z+mExaOytXecNr9aTq98OnTv67eUHkrd3Q7c8XgT/vTdMLCUbnaG067P00nLByVq73htPvTdIbh83N1pB+/fnN8eHLRt+spAF6oP01nED4/uzO5/Qhcv5Jm91Tx/4CVNEr8aTqDcH3NbvTKXbXx/Hlra+0c88OJBIEvd77Hjx7rq+5+qKKHt0GAVw6eeMOY087HRv4oAF45+FitFrxyf5pOWDgqV3vDafen6YSFSzwKRZ8/TScsjAcjKPSn6YSFZT4KRfnkSxL483Px/veP25EPSOzxAE/603QG4fPz5vjhZYRtKfJRKABP+tN0BuHqOF6Bz3bPHcAs6k/TGYTrHj96rf5m7sh2gF/Un6YzDPtv58a5R5zOAfyi/jSdsLDMyR38SX+aTlgY76RR6N/shebaTO4erw7v6PHq/Gk6r8JuJB+/A0fg6Rz8SX+azkj4gLtsV+FP03kVvt7jb+fOXTH40/40nUGYGONbSbpWD3/Sn6YTFo7K1d5w2v1pOr0wVtKsy5+mExYucSOGPn+aziBM3F6N83h1/jSdXri7y3ZshifxRgz4k/40nUGY+EIWPV6dP00nLFziyp0+f5rOMIzHna3In6YzCONxZ2vyp+kMwjcfd4Y3VCjyp+kMwjcfdwbwivxpOsPwrcedAbwif5pOWDgqV3vDafen6YSFo3K1N5x2f5pOL3xjfTyZO7qduWLwp/1pOmHhqFztDafdn6YTFo7K1d5w2v1pOsPw9UWTt3Nnr5h6f+YFJzSdQZhaNHkrd2Q7d8Mp909s3jzp3ZW7nIsmmRtOu39i8+ZJ7/f4bIsmmRtOu39i8+ZJv4zx1xZNTrfWDsYS+KzW2sHYA/8/HOrn8J9HIeCPD+6i3fkZV+5m8Z9HAeDds6v39weM8TP5z6OQa/XVadzpceorhQE+1j+xefOkd+CnXrYjrLWDsQV+4sUbylo7GICPtNYOxg548vv4asp/v8d99Rn9A7XwBRz3XhJ33zXeSZPNfx6lgndjgLvVEmvnsvnPI/R4cf7zKPlafTXGbzDG5/QPFL6kmd1/ljtkops3TzrAZ69+Li0N3t6jUAK1cvAGH4wQqJWDN/golEAtNl8PE3r8ZP9ArRy8wUehrEOY1U/2F6KlZ/XTcwE+i5YGj9O5a9WMzpzFH5O7yf6BWjl4g++kCdTKwaPHX5Pc2YEXTucm+wdq7eCn5xoBL1wAP9lfiJY+nWuEa/VzSwj4CblGwK98Vh+RC/BZtDR4XLm7Vs3ozFn8cR4/2T9QcmcHXrgRY7J/oFYOHj1eqXDlbrK/EC09uZueC/BZBPBz+ydWP5dEgDf1hopAAfyb7cxgAD5DOsCHNcCE6gsRxvjJ/onVFyKAn+y/DgH8ZH8hEjHGT8oF+CwC+Ln9E6ufSwA/t39i9XMJ4Of2T6x+LgH83P6J1RcigJ/sn1h9IQL4yf7rEMBP9hcijPFz+wsRwM/tn1j9XAL4uf0Tq59LAD+3f2L1cwng5/ZPrL4QAfxk/8TqC9ES4Jmf/iwEvHAlg5++di5Q0elGwC88xkespAkUwNNaGHzE2rlAaQe/8lk9X4+PFsBnSL/tPn3tHLcAPkM6x6yeW0bAJ0oueIzxrAJ4LvDCBfBawS99Onf9jcMAz6qlJ3fn57EFk2G5ibu+ligD/Opn9aeP2+hcFgF8hnSczsUXI2OVGPwBXiv4ROHbOYCPCOPbObVi+HYu/Q3ZYbu+mmgD/Gq/nQN4WktP7ti+ndMOHrP6uQXwGdIBPr4YGavE4J8LfP5br6JlBHyi5PZ4jPGsAngu8MKFK3daweM8/k0iwKenx1y5C85N3PXVRBngVz6rx331V4uRsUoM/nKv3EUL4DOk4wJOfDEyVolBcsFjjGdVHvCT3lARKO3ghWuN4JkfvCBEIsZ4UeCNSAT47Lnp6fBPStc4qw+UcDDc/gBv1B/gtfonSi547WAAfpl0iBbAa9Vqx3iAp7UO8AtcRtM+xq8D/AISDobbH+CN+gO8Vv9EAbxW/0TZBW9cAK9VGOONCuAjpX2MB/hICQfD7Z8M/vhQ3G1FLZMOlHAwr8yyX9lMBe9W0rinmgL83P6JSgVfA9/dA/zc/onK0eMr7b/6Rht440oe40+P/tbqffbHlkOssjurNy674DHGJ4TZcmcQwCeE2XJnEMAnhDnfScMtgE8Il4zvpOEWwCeEncS9kwYKkd0x3rgA3qhyfDs3PreTDh5jfEJY5HPuAgXwCWHOd9JwC+ATwujxy/knKsO3cxjjF/FPFGb1RgXwRpULvL5br4zLbo/HGJ8QZsudQQCfEC5x5W4x/0ThPF6rf6IYrtwF5y4r4StduGW3xxuX3St3xmV3Vm9cdsELLx638oDneEMFt4QXj1sAb1QAb1RGxnh959ncMgIeei2ANyqANyqANyqANyqANyqANyqANyqANyqANyqANyqANyqANypO8JBk8YFPlPb73nX7A7xRf4A36g/wRv0B3qg/wBv1B3ij/rgIY1QAb1QAb1QAb1QAb1QAb1QAb1QAb1QAb1QAb1SLgj++fTV5TveHonhi9D+MPgosp9pHzXFoSfAH1oZzr8s7fr1l83d/tft7NnunPeMf7iLgd0/l8cPL7u5nph7v/f99X//E5e+e98h0yGr8j99+tzLwh437x3eob/2vvyQzkz9Tj6/9z59/Xduh/vT9yz8cES7wrf/11+Jm8T8+3PGMJLX/frO6Mf78+ZfvGY+Urf/pkYd7V36uI4r3rw72qwNf7n/wSNhm9d7/+MDWbE35ueYQ3n/vb45n+tNdCnwz22YD7/wZuXt/9zhvph7fts/6evz5J0+cDbzzr3sMT8v58lc7YBrj2/ZZH/jjX+C/pH+5EPg9V0+Bf7Bwrd6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oAN6oDIGvb12s1z416t3tWd8oPXL75/nZr8XiXSU3vwyBr9+FPvpC9JIAX9+rzbqudwlZAu86+/nztlk/ffz2u3e/VTyb1dS7H/zGasPp0a/ivayCrnr7jm1hw1KyBN5D//Di109/88UtuKj+a34rd+9f3Eb308Ythjx96lZBnz7+3B8f1iFL4N1hvjnSV1gd4+YI7iC7Q/3uqflLqDb0F8lwrlNfSqbAHz/88dnh3LmjeAfe/1a65a81+MfCL5GphoD29vb1jfDGwJ9/+q06Zp8e/TG+Ad/85np8Ne13Gz51lN3yOCeA1656Fa0j/vW2Ad/85mZwlzG+Iu6gA/xaVK9C3RfFn757ag/19W9uVn+3bWf17hi/uzzbCOCh1QjgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjQrgjer/4XPPnm5sfB4AAAAASUVORK5CYII=" alt="plot of chunk unnamed-chunk-31"/></p>

<p>For each drawn sample, the estimates related to the Y&#39;s are calculated. 
Their mean and standard deviation are also computed, in order to produce the CV related to each variable in every domain. 
These CV&#39;s can be inspected and compared to the constraints:</p>

<pre><code class="r">eval$coeff_var
</code></pre>

<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> domain </th>
   <th style="text-align:right;"> cv(Y1) </th>
   <th style="text-align:right;"> cv(Y2) </th>
   <th style="text-align:right;"> cv(Y3) </th>
   <th style="text-align:right;"> cv(Y4) </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #bde9d0">0.0800</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c2ebd4">0.0778</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #caefda">0.0747</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c8eed8">0.0755</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">0.0671</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #cef0dd">0.0733</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #d1f1df">0.0721</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #beead1">0.0794</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 3 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c6edd7">0.0764</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b7e6cb">0.0824</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #caeeda">0.0749</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c7edd8">0.0759</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 4 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b7e6cb">0.0824</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c8eed8">0.0756</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #bbe8ce">0.0809</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #caefda">0.0746</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 5 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b1e4c7">0.0846</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #aae1c2">0.0873</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a5dfbe">0.0894</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b4e5c9">0.0836</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 6 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #cef0dc">0.0734</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #cff0dd">0.0730</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #d1f1df">0.0719</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #dbf6e7">0.0679</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 7 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b2e5c8">0.0843</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #9adbb6">0.0938</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a2debc">0.0904</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">0.1101</span> </td>
  </tr>
</tbody>
</table>

<pre><code class="r">swisserrors
#&gt;    DOM  CV1  CV2  CV3  CV4 domainvalue
#&gt; 1 DOM1 0.08 0.12 0.08 0.12           1
#&gt; 2 DOM1 0.08 0.12 0.08 0.12           2
#&gt; 3 DOM1 0.08 0.12 0.08 0.12           3
#&gt; 4 DOM1 0.08 0.12 0.08 0.12           4
#&gt; 5 DOM1 0.08 0.12 0.08 0.12           5
#&gt; 6 DOM1 0.08 0.12 0.08 0.12           6
#&gt; 7 DOM1 0.08 0.12 0.08 0.12           7
</code></pre>

<p>These values are on average compliant with the precision constraints set. </p>

<p>We can also inspect the relative bias:</p>

<pre><code class="r">eval$rel_bias
</code></pre>

<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> domain </th>
   <th style="text-align:right;"> bias(Y1) </th>
   <th style="text-align:right;"> bias(Y2) </th>
   <th style="text-align:right;"> bias(Y3) </th>
   <th style="text-align:right;"> bias(Y4) </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c9eed9">-0.0102</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">-0.0127</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #dbf5e7">-0.0124</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #d3f2e0">-0.0114</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #7fcfa1">-0.0012</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #7dcfa0">-0.0010</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #8bd4aa">-0.0027</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #96d9b2">-0.0040</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 3 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #bbe8ce">-0.0085</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #d4f3e2">-0.0116</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #afe3c6">-0.0071</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #9ddcb8">-0.0049</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 4 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #96d9b3">-0.0041</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #99dab5">-0.0044</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #9bdbb6">-0.0046</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #89d4a9">-0.0025</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 5 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">0.0005</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #7cce9f">-0.0009</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #7bce9f">-0.0008</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #77cc9b">-0.0003</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 6 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #cff1de">-0.0110</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c4ecd5">-0.0096</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b8e7cc">-0.0081</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #beead1">-0.0089</span> </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 7 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a5dfbe">-0.0059</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a5dfbe">-0.0058</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a2debc">-0.0055</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #7ace9e">-0.0007</span> </td>
  </tr>
</tbody>
</table>

<p>It is also possible to analyse the sampling distribution of the estimates for each variable of interest in a selected domain:</p>

<pre><code class="r">dom = 1
hist(eval$est$Y1[eval$est$dom == dom], col = &quot;grey&quot;, border = &quot;white&quot;,
     xlab = expression(hat(Y)[1]),
     freq = FALSE,
     main = paste(&quot;Variable Y1 Domain &quot;,dom,sep=&quot;&quot;))
abline(v = mean(eval$est$Y1[eval$est$dom == dom]), col = &quot;blue&quot;, lwd = 2)
abline(v = mean(swissframe$Y1[swissframe$domainvalue==dom]), col = &quot;red&quot;)
legend(&quot;topright&quot;, c(&quot;distribution mean&quot;, &quot;true value&quot;),
       lty = 1, col = c(&quot;blue&quot;, &quot;red&quot;), box.col = NA, cex = 0.8)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-34"/></p>

<h1>Handling &#39;take-all&#39; strata in the optimization step</h1>

<p>As input to the optimization step, together with proper sampling strata, it is also possible to provide <em>take-all</em> strata. These strata will not be subject to optimisation as the proper strata, but they will contribute to the determination of the best stratification, as their presence in a given domain will permit to satisfy precision constraint with a lower number of units belonging to proper sampling strata.</p>

<p>In order to correctly execute the optimization and further steps, it is necessary to perform a pre-processing of the overall input.
The first step to be executed consists in the bi-partition of units to be censused and of units to be sampled, in order to build two different frames.
As an example, we take the units with the highest values of the auxiliary variables as the ones to be selected in any case:</p>

<pre><code class="r">data(swisserrors)
data(swissstrata)
data(swissframe)
#----Selection of units to be censused from the frame
ind_framecens &lt;- which(swissframe$X1 &gt; 12 |
                       swissframe$X2 &gt; 2 | 
                       swissframe$X3 &gt; 2 |
                       swissframe$X4 &gt; 2 |
                       swissframe$X5 &gt; 2 | 
                       swissframe$X6 &gt; 2 )
framecens &lt;- swissframe[ind_framecens,]
nrow(framecens)
#&gt; [1] 302
#----Selection of units to be sampled from the frame
# (complement to the previous)
framesamp &lt;- swissframe[-ind_framecens,]
nrow(framesamp)
#&gt; [1] 2594
</code></pre>

<p>In this way, we have included all units to be surely selected in &#39;framecens&#39;, and the remaining in &#39;framesamp&#39;. At the end of the process, 
the sample will be selected only from &#39;framesamp&#39;, while the units in &#39;framecens&#39; will be simply added to the sample.</p>

<p>We can obtain census strata and sampling strata by applying <em>buildStrataDF</em> respectively to <em>framecens</em> and <em>framesamp</em>:</p>

<pre><code class="r"># Build strata to be censused and sampled
cens &lt;- buildStrataDF(framecens,progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  231
#&gt; ... of which with only one unit:  187
sum(cens$N)
#&gt; [1] 302
strata &lt;- buildStrataDF(framesamp,progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  410
#&gt; ... of which with only one unit:  202
sum(strata$N)
#&gt; [1] 2594
</code></pre>

<p>and</p>

<pre><code class="r">sum(cens$N)
#&gt; [1] 302
sum(strata$N)
#&gt; [1] 2594
</code></pre>

<p>Now we have all required inputs to run &#39;optimizeStrata&#39; in presence of the &#39;take-all&#39; strata:</p>

<pre><code class="r">solution2 &lt;- optimizeStrata(
    errors = swisserrors, 
    strata = strata, 
    cens = cens, 
    strcens = TRUE,
    parallel = TRUE,
    writeFiles = TRUE,
    showPlot = FALSE
)
</code></pre>

<p>Once the optimized solution has been produced, the next steps are executed by considering only the sampling part of the frame:</p>

<pre><code class="r">newstrata &lt;- updateStrata(strata, solution2)
# updating sampling frame with new strata labels
framenew &lt;- updateFrame(frame=framesamp,newstrata=newstrata)
# selection of sample from sampling strata
sample &lt;- selectSample(frame=framenew,outstrata=solution2$aggr_strata)
#&gt; 
#&gt; *** Sample has been drawn successfully ***
#&gt;  182  units have been selected from  65  strata
#&gt; 
#&gt; ==&gt; There have been  6  take-all strata 
#&gt; from which have been selected  7 units
</code></pre>

<p>Finally, the units in the &#39;take-all&#39; strata can be added to sampled ones.
First, the census frame needs to be made homogeneous to the sample frame in order to permit the &#39;rbind&#39; step:</p>

<pre><code class="r"># addition of necessary variables to 
colnames(framesamp) &lt;- toupper(colnames(framesamp))
colnames(framecens) &lt;- toupper(colnames(framecens))
framecens$WEIGHTS &lt;- rep(1,nrow(framecens))
framecens$FPC &lt;- rep(1,nrow(framecens))
framecens$LABEL &lt;- rep(&quot;999999&quot;,nrow(framecens))
framecens$STRATUM &lt;- rep(&quot;999999&quot;,nrow(framecens))
framecens$STRATO &lt;- rep(&quot;999999&quot;,nrow(framecens))
</code></pre>

<p>The overall set of units to be surveyed is obtainable in this way:</p>

<pre><code class="r">survey &lt;- rbind(sample,framecens)
</code></pre>

<p>and this is the proportion of sampling and censused units:</p>

<pre><code class="r">survey$cens &lt;- ifelse(survey$LABEL == &quot;999999&quot;,1,0)
table(survey$cens)
#&gt; 
#&gt;   0   1 
#&gt; 182 302
</code></pre>

<p>In order to verify compliance to the precision constraint, we perform the following:</p>

<pre><code class="r">cens2 &lt;- cens[,-c(14:19)]
cens2$SOLUZ &lt;- cens2$N
stratatot &lt;- rbind(solution2$aggr_strata,cens2)
expected_CV(stratatot)
#&gt;      cv(Y1) cv(Y2) cv(Y3) cv(Y4)
#&gt; DOM1  0.078  0.073  0.076  0.080
#&gt; DOM2  0.075  0.074  0.076  0.079
#&gt; DOM3  0.078  0.078  0.076  0.080
#&gt; DOM4  0.080  0.074  0.080  0.087
#&gt; DOM5  0.075  0.079  0.077  0.075
#&gt; DOM6  0.073  0.078  0.080  0.084
#&gt; DOM7  0.078  0.078  0.075  0.085
</code></pre>

<h1>Handling Anticipated Variance</h1>

<p>In the previous sections it has been assumed that, when optimizing the stratification of a sampling frame, values of the target
variables Y&#39;s are available for the generality of the units in the frame, or at least for a sample of them by means of which it
is possible to estimate means and standard deviation of Y&#39;s in atomic strata. 
Of course, this assumption is seldom expected to hold.
The situation in which some proxy variables are available in the frame is much more likely to happen. In these situations, instead
of directly indicating the real target variables, proxy ones are named as Y&#39;s.
By so doing, there is no guarantee that the final stratification and allocation can ensure the compliance to the set of precision constraints.<br/>
In order to take into account this problem, and to limit the risk of overestimating the expected precision levels of the optimized solution, it is possible to carry out the optimization by 
considering, instead of the expected coefficients of variation related to proxy variables, the anticipated coefficients of variation (ACV) that depend on the model that is possile to fit on couples of real target variables and proxy ones.
In the current implementation, only models linking continuous variables can be considered. 
The definition and the use of these models is the same that has been implemented in the package <em>stratification</em> [see @baillargeon:2014]. 
In particular, the reference here is to two different models, the linear model with heteroscedasticity: </p>

<p>\[Y=beta\times X + epsilon\]</p>

<p>where </p>

<p>\[epsilon \sim N(0,sig2 X^{gamma})\]</p>

<p>(in case gamma = 0, then the model is homoscedastic)</p>

<p>and the loglinear model: </p>

<p>\[Y= \exp (beta \times log(X) + epsilon)\]</p>

<p>where</p>

<p>\[epsilon \sim N(0,sig2)\]</p>

<p>In order to make evident the importance of the above, consider the following example, based on the dataset <em>nations</em> available in the package.</p>

<pre><code class="r">data(nations)
head(nations)
#&gt;          Country  TFR contraception infant.mortality   GDP  region
#&gt; 1    Afghanistan 6.90            63              154  2848    Asia
#&gt; 2        Albania 2.60            47               32   863  Europe
#&gt; 3        Algeria 3.81            52               44  1531  Africa
#&gt; 4 American-Samoa 1.35            71               11  2433 Oceania
#&gt; 5        Andorra 1.61            71                7 19121  Europe
#&gt; 6         Angola 6.69            19              124   355  Africa
#&gt;   Continent
#&gt; 1         2
#&gt; 2         1
#&gt; 3         4
#&gt; 4         5
#&gt; 5         1
#&gt; 6         4
</code></pre>

<p>Let us assume that in the sampling frame only variable <em>GDP</em> (Gross Domestic Product) is available for all countries, while <em>contraception rates</em> and <em>infant mortality rates</em> are available only on a subset of countries (about one third).</p>

<pre><code class="r">set.seed(1234)
nations_sample &lt;- nations[sample(c(1:207),70),]
</code></pre>

<p>In this subset we can fit models between GDP and the two variables that we assume are the target of our survey.</p>

<p>One model for <em>infant mortality</em> and <em>GDP</em>:</p>

<pre><code class="r">mod_logGDP_INFMORT &lt;- lm(log(nations_sample$infant.mortality) ~ log(nations_sample$GDP))
summary(mod_logGDP_INFMORT)
#&gt; 
#&gt; Call:
#&gt; lm(formula = log(nations_sample$infant.mortality) ~ log(nations_sample$GDP))
#&gt; 
#&gt; Residuals:
#&gt;     Min      1Q  Median      3Q     Max 
#&gt; -1.1292 -0.3765 -0.1455  0.3316  2.6345 
#&gt; 
#&gt; Coefficients:
#&gt;                         Estimate Std. Error t value             Pr(&gt;|t|)
#&gt; (Intercept)              6.86295    0.33620   20.41 &lt; 0.0000000000000002
#&gt; log(nations_sample$GDP) -0.46580    0.04389  -10.61 0.000000000000000452
#&gt;                            
#&gt; (Intercept)             ***
#&gt; log(nations_sample$GDP) ***
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 0.6158 on 68 degrees of freedom
#&gt; Multiple R-squared:  0.6236, Adjusted R-squared:  0.6181 
#&gt; F-statistic: 112.7 on 1 and 68 DF,  p-value: 0.0000000000000004523
</code></pre>

<p>and one model for <em>contraception</em> and <em>GDP</em>:</p>

<pre><code class="r">mod_logGDP_CONTRA &lt;- lm(log(nations_sample$contraception) ~ log(nations_sample$GDP))
summary(mod_logGDP_CONTRA)
#&gt; 
#&gt; Call:
#&gt; lm(formula = log(nations_sample$contraception) ~ log(nations_sample$GDP))
#&gt; 
#&gt; Residuals:
#&gt;      Min       1Q   Median       3Q      Max 
#&gt; -1.96139 -0.27360 -0.01435  0.45058  1.25143 
#&gt; 
#&gt; Coefficients:
#&gt;                         Estimate Std. Error t value         Pr(&gt;|t|)    
#&gt; (Intercept)              0.98318    0.30538   3.220          0.00197 ** 
#&gt; log(nations_sample$GDP)  0.34649    0.03986   8.692 0.00000000000122 ***
#&gt; ---
#&gt; Signif. codes:  0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1
#&gt; 
#&gt; Residual standard error: 0.5593 on 68 degrees of freedom
#&gt; Multiple R-squared:  0.5263, Adjusted R-squared:  0.5193 
#&gt; F-statistic: 75.55 on 1 and 68 DF,  p-value: 0.000000000001217
</code></pre>

<p>We define the <em>sampling frame</em> in this way:</p>

<pre><code class="r">nations$progr &lt;- c(1:nrow(nations))
nations$dom &lt;- 1
frame &lt;- buildFrameDF(nations,
                      id=&quot;Country&quot;,
                      X=&quot;progr&quot;,
                      Y=c(&quot;GDP&quot;,&quot;GDP&quot;),
                      domainvalue = &quot;dom&quot;)
</code></pre>

<p>that is, we replicate twice the variable <em>GDP</em> because it will be used once for <em>infant mortality</em> and once for <em>contraception</em>. </p>

<p>We set 10% and 5% precision constraints on these two variables:</p>

<pre><code class="r">cv &lt;- as.data.frame(list(DOM=rep(&quot;DOM1&quot;,1),
                         CV1=rep(0.10,1),
                         CV2=rep(0.05,1),
                         domainvalue=c(1:1)
                    ))
cv
#&gt;    DOM CV1  CV2 domainvalue
#&gt; 1 DOM1 0.1 0.05           1
</code></pre>

<p>We build the strata without any assumption on the variability of the two target variables, and proceed in the optimization:</p>

<pre><code class="r">strata1 &lt;- buildStrataDF(frame, progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  207
#&gt; ... of which with only one unit:  207
solution3 &lt;- optimizeStrata(cv,
                           strata1,
                           iter = 50,
                           pops = 20,
                           parallel = FALSE,
                           suggestions = KmeansSolution(strata1,cv),
                           writeFiles = FALSE,
                           showPlot = FALSE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-50"/></p>

<pre><code>#&gt; 
#&gt; -----------------
#&gt;  Kmeans solution 
#&gt; -----------------
#&gt;  *** Domain:  1  ***
#&gt;  Number of strata:  7
#&gt;  Sample size     :  17
#&gt;  *** Domain :  1   1
#&gt;  Number of strata :  207
#&gt; ---------------------------------------------
#&gt; Optimal stratification with Genetic Algorithm
#&gt; ---------------------------------------------
#&gt;  *** Parameters ***
#&gt; ---------------------------
#&gt; Domain:  1
#&gt; Maximum number of strata:  207
#&gt; Minimum number of units per stratum:  2
#&gt; Take-all strata (TRUE/FALSE):  FALSE
#&gt; number of sampling strata :  207
#&gt; Number of target variables:  2
#&gt; Number of domains:  1
#&gt; Number of GA iterations:  50
#&gt; Dimension of GA population:  20
#&gt; Mutation chance in GA generation:  NA
#&gt; Elitism rate in GA generation:  0.2
#&gt; Chance to add strata to maximum:  0
#&gt; Allocation with real numbers instead of integers:  TRUE
#&gt; Suggestion:  5 3 3 6 6 7 5 6 7 4 2 7 2 2 2 7 6 6 5 7 6 1 7 6 1 6 5 5 7 6 2 6 7 6 1 5 7 6 2 1 3 3 6 6 6 1 2 2 4 6 4 5 7 7 5 7 6 5 1 1 1 1 7 5 6 4 5 4 7 3 6 4 6 4 6 2 5 1 7 6 6 5 1 6 5 6 7 7 2 2 2 5 6 6 5 6 7 5 7 5 5 6 3 6 6 3 3 2 4 6 7 6 6 5 6 5 5 6 7 6 6 6 6 6 5 5 3 7 6 6 7 6 6 3 7 6 6 4 6 7 6 5 7 4 5 5 7 1 5 6 2 6 3 5 7 3 7 7 7 6 6 5 6 6 5 3 2 3 3 4 6 7 6 2 4 6 1 5 1 3 7 6 6 6 6 4 6 3 5 2 6 7 7 1 3 3 6 3 6 7 2 7 7 6 6 6 1
#&gt;  *** Sample cost:  16.68519
#&gt;  *** Number of strata:  7
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-50"/></p>

<pre><code>#&gt; 
#&gt;  *** Sample size :  17
#&gt;  *** Number of strata :  7
#&gt; ---------------------------
sum(solution3$aggr_strata$SOLUZ)
#&gt; [1] 16.68519
</code></pre>

<p>Then, we evaluate the expected CV&#39;s on the three variables:</p>

<pre><code class="r">newstrata &lt;- updateStrata(strata1,solution3)
framenew1 &lt;- updateFrame(frame,newstrata)
framenew1 &lt;- framenew1[order(framenew1$ID),]
framenew1$Y2 &lt;- nations$infant.mortality
framenew1$Y3 &lt;- nations$contraception
results1 &lt;- evalSolution(framenew1, solution3$aggr_strata, 50, progress = FALSE)
results1$coeff_var
</code></pre>

<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> domain </th>
   <th style="text-align:right;"> cv(Y1) </th>
   <th style="text-align:right;"> cv(Y2) </th>
   <th style="text-align:right;"> cv(Y3) </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">0.0463</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">0.2289</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #b6e6cb">0.1123</span> </td>
  </tr>
</tbody>
</table>

<p>Clearly, the CV&#39;s on <em>infant mortality</em> and <em>contraception</em> are not compliant with the corresponding precision constraints.</p>

<p>We now proceed in building the <em>strata</em> dataframe using the models:</p>

<pre><code class="r">model &lt;- NULL
model$beta[1] &lt;- mod_logGDP_INFMORT$coefficients[2]
model$sig2[1] &lt;- summary(mod_logGDP_INFMORT)$sigma
model$type[1] &lt;- &quot;loglinear&quot;
model$gamma[1] &lt;- 0
model$beta[2] &lt;- mod_logGDP_CONTRA$coefficients[2]
model$sig2[2] &lt;- summary(mod_logGDP_CONTRA)$sigma
model$type[2] &lt;- &quot;loglinear&quot;
model$gamma[2] &lt;- 0
model &lt;- as.data.frame(model)
model
#&gt;         beta      sig2      type gamma
#&gt; 1 -0.4658038 0.6157600 loglinear     0
#&gt; 2  0.3464857 0.5593031 loglinear     0
</code></pre>

<pre><code class="r">strata2 &lt;- buildStrataDF(frame, model = model, progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  207
#&gt; ... of which with only one unit:  207
head(strata2)
#&gt;     STRATO N          M1        M2          S1        S2 COST CENS DOM1
#&gt; 1        1 1 0.024595860 15.737965 0.022690436 13.624506    1    0    1
#&gt; 10      10 1 0.009910578 30.945032 0.009142812 26.789408    1    0    1
#&gt; 100    100 1 0.011086660 28.468488 0.010227784 24.645441    1    0    1
#&gt; 101    101 1 0.067027720  7.465936 0.061835128  6.463332    1    0    1
#&gt; 102    102 1 0.064539738  7.678981 0.059539888  6.647767    1    0    1
#&gt; 103    103 1 0.030744575 13.331076 0.028362814 11.540840    1    0    1
#&gt;      X1
#&gt; 1     1
#&gt; 10   10
#&gt; 100 100
#&gt; 101 101
#&gt; 102 102
#&gt; 103 103
</code></pre>

<p>We proceed with the optimization</p>

<pre><code class="r">strata2 &lt;- buildStrataDF(frame, model = model, progress = FALSE)
#&gt; 
#&gt; Computations are being done on population data
#&gt; 
#&gt; Number of strata:  207
#&gt; ... of which with only one unit:  207
solution4 &lt;-
  optimizeStrata(
    errors = cv , 
    strata = strata2, 
    iter = 50, 
    pops = 20, 
    parallel = FALSE,
    suggestions = KmeansSolution(strata2,cv),
    showPlot = FALSE,
    writeFiles = FALSE)
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-54"/></p>

<pre><code>#&gt; 
#&gt; -----------------
#&gt;  Kmeans solution 
#&gt; -----------------
#&gt;  *** Domain:  1  ***
#&gt;  Number of strata:  11
#&gt;  Sample size     :  113
#&gt;  *** Domain :  1   1
#&gt;  Number of strata :  207
#&gt; ---------------------------------------------
#&gt; Optimal stratification with Genetic Algorithm
#&gt; ---------------------------------------------
#&gt;  *** Parameters ***
#&gt; ---------------------------
#&gt; Domain:  1
#&gt; Maximum number of strata:  207
#&gt; Minimum number of units per stratum:  2
#&gt; Take-all strata (TRUE/FALSE):  FALSE
#&gt; number of sampling strata :  207
#&gt; Number of target variables:  2
#&gt; Number of domains:  1
#&gt; Number of GA iterations:  50
#&gt; Dimension of GA population:  20
#&gt; Mutation chance in GA generation:  NA
#&gt; Elitism rate in GA generation:  0.2
#&gt; Chance to add strata to maximum:  0
#&gt; Allocation with real numbers instead of integers:  TRUE
#&gt; Suggestion:  7 8 8 2 2 6 7 10 9 4 11 6 3 11 3 6 5 5 4 9 2 1 6 2 1 2 7 7 6 2 3 2 9 5 1 7 6 5 3 1 8 8 2 5 10 1 3 11 4 10 4 7 9 6 7 9 2 7 1 1 8 1 6 7 2 4 7 4 9 8 5 4 10 4 2 3 7 1 9 10 5 7 8 10 7 5 9 6 3 3 11 7 5 5 7 2 6 4 6 7 7 2 8 2 10 8 8 3 4 2 9 9 2 7 2 7 7 10 6 2 10 5 9 2 7 4 8 6 5 5 6 5 10 8 9 2 5 4 10 7 2 7 9 4 7 4 6 1 4 5 11 9 8 7 6 8 6 9 6 2 5 7 5 2 7 3 3 3 8 4 2 6 2 3 4 2 1 7 1 8 6 2 5 10 2 1 10 3 4 3 2 9 6 1 8 8 2 8 10 6 11 9 9 2 10 2 1
#&gt;  *** Sample cost:  108.8512
#&gt;  *** Number of strata:  11
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-54"/></p>

<pre><code>#&gt; 
#&gt;  *** Sample size :  109
#&gt;  *** Number of strata :  11
#&gt; ---------------------------
</code></pre>

<p>This time the sample size is much higher.</p>

<p>What about the expected CV&#39;s?</p>

<pre><code class="r">newstrata &lt;- updateStrata(strata2,solution4)
framenew2 &lt;- updateFrame(frame,newstrata)
framenew2 &lt;- framenew2[order(framenew2$ID),]
framenew2$Y2 &lt;- nations$infant.mortality
framenew2$Y3 &lt;- nations$contraception
results2 &lt;- evalSolution(framenew2, solution4$aggr_strata, 50, progress = FALSE)
results2$coeff_var
</code></pre>

<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> domain </th>
   <th style="text-align:right;"> cv(Y1) </th>
   <th style="text-align:right;"> cv(Y2) </th>
   <th style="text-align:right;"> cv(Y3) </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">0.0062</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">0.0458</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a2debc">0.0277</span> </td>
  </tr>
</tbody>
</table>

<p>This time the expected CV&#39;s of all variables are more than compliant with the precision constraints.</p>

<h1>Optimization variant with the <em>optimizeStrata2</em> function</h1>

<p>Function <em>optimizeStrata2</em> performs the same task than <em>optimizeStrata</em>, but with a different Genetic Algorithm, operating on a genome represented by vector containing real values, instead of integers. This permits to operate directly on the boundaries of the strata, instead of aggregating the initial atomic strata. In some situations (not exceedingly too big size of the sampling frame) this new function is much more efficient. Furthermore, resulting strata are guaranteed to not overlap with respect to the different stratification variables. A major limitation is in the nature of the stratification variables, that are required to be all continuous (though categorical ordinal can be handled). Another one is in the fact that it is necessary to choose the number of strata (it is not optimally determined during the evolution process as in the case of <em>optimizeStrata</em>).</p>

<p>To operate with <em>optimizeStrata2</em> it is no more necessary to produce the <em>strata</em> dataframe. </p>

<p>Let us consider the following example: </p>

<pre><code class="r">data(&quot;swissmunicipalities&quot;)
swissmunicipalities$id &lt;- c(1:nrow(swissmunicipalities))
swissmunicipalities$dom &lt;- 1
frame &lt;- buildFrameDF(swissmunicipalities,
                      id = &quot;id&quot;,
                      domainvalue = &quot;REG&quot;,
                      X = c(&quot;Surfacesbois&quot;,&quot;Surfacescult&quot;),
                      Y = c(&quot;Pop020&quot;, &quot;Pop2040&quot;)
)
# choice of units to be selected in any case (census units)
framecens &lt;- frame[frame$X1 &gt; 2500 
                   | frame$X2 &gt; 1200,]
# remaining units 
framesamp &lt;- frame[!(frame$id %in% framecens$id),]
# precision constraints
errors &lt;- NULL
errors$DOM &lt;- &quot;DOM1&quot;
errors$CV1 &lt;- 0.1
errors$CV2 &lt;- 0.1
errors &lt;- as.data.frame(errors)
errors &lt;- errors[rep(row.names(errors),7),]
errors$domainvalue &lt;- c(1:7)
errors
#&gt;      DOM CV1 CV2 domainvalue
#&gt; 1   DOM1 0.1 0.1           1
#&gt; 1.1 DOM1 0.1 0.1           2
#&gt; 1.2 DOM1 0.1 0.1           3
#&gt; 1.3 DOM1 0.1 0.1           4
#&gt; 1.4 DOM1 0.1 0.1           5
#&gt; 1.5 DOM1 0.1 0.1           6
#&gt; 1.6 DOM1 0.1 0.1           7
</code></pre>

<p>By so doing, we have chosen two stratification variables (<em>Surfacesbois</em> and  <em>Surfacescult</em>) and two target variables (<em>Pop020</em> and <em>Pop2040</em>), on both of which we have set the same precision constraint (a maximum CV equal to 10%).</p>

<p>Now the execution of the optimization step (for the domain 4) using <em>optimizeStrata2</em> is straightforward, as we do not need to categorize stratification variables and to generate the atomic strata:</p>

<pre><code class="r">solution5 &lt;- optimizeStrata2 (
  errors, 
  framesamp = framesamp,
  framecens = framecens, 
  strcens = TRUE, 
  alldomains = FALSE,
  dom = 4,
  iter = 50,
  pops = 20,
  nStrata = 5,
  writeFiles = FALSE,
  showPlot = FALSE,
  parallel = FALSE
)
</code></pre>

<pre><code class="r">sum(round(solution5$aggr_strata$SOLUZ))
#&gt; [1] 35
expected_CV(solution5$aggr_strata)
#&gt;      cv(Y1) cv(Y2)
#&gt; DOM1    0.1  0.098
</code></pre>

<p>This function also outputs the new version of the overall frame (sampling plus census), already provided with the labels indicating to which stratum each unit belongs:</p>

<pre><code class="r">framenew &lt;- solution5$framenew
table(framenew$LABEL)
#&gt; 
#&gt;  1  2  3  4  5  6 
#&gt; 27 52 32 49  5  6
</code></pre>

<p>The first 5 strata are the ones pertaining to sampling units, the 6th is the one with censused units.</p>

<p>It is also possible to investigate the distribution of population units in the strata by using the function <em>plotStrata2d</em>:</p>

<pre><code class="r">outstrata &lt;- plotStrata2d(
                  solution5$framenew, 
                  solution5$aggr_strata,
                  domain = 4, 
                  vars = c(&quot;X1&quot;,&quot;X2&quot;),
                  labels =     c(&quot;Surfacesbois&quot;,&quot;Surfacescult&quot;)
                  )
</code></pre>

<p><img src="data:image/png;base64,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" alt="plot of chunk unnamed-chunk-60"/></p>

<p>Together with the plot, also a tabular format of the optimized strata is produced by <em>plotStrata2d</em>:</p>

<pre><code class="r">outstrata
</code></pre>

<table class="table table-condensed">
 <thead>
  <tr>
   <th style="text-align:right;"> Stratum </th>
   <th style="text-align:right;"> Population </th>
   <th style="text-align:right;"> Allocation </th>
   <th style="text-align:right;"> SamplingRate </th>
   <th style="text-align:right;"> Bounds Surfacesbois </th>
   <th style="text-align:right;"> Bounds Surfacescult </th>
  </tr>
 </thead>
<tbody>
  <tr>
   <td style="text-align:right;"> 1 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #aae1c2">27</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">4</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 13.17%">0.13167379</span> </td>
   <td style="text-align:right;"> 5-189 </td>
   <td style="text-align:right;"> 40-167 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 2 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">52</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c2ebd4">5</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 9.33%">0.09334017</span> </td>
   <td style="text-align:right;"> 21-215 </td>
   <td style="text-align:right;"> 156-665 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 3 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #9fddb9">32</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #8cd5ab">7</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 21.28%">0.21284696</span> </td>
   <td style="text-align:right;"> 153-297 </td>
   <td style="text-align:right;"> 160-738 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 4 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #77cc9c">49</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #71ca97">8</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 17.21%">0.17212183</span> </td>
   <td style="text-align:right;"> 125-1126 </td>
   <td style="text-align:right;"> 239-890 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 5 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #def7e9">5</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #c2ebd4">5</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 100.00%">1.00000000</span> </td>
   <td style="text-align:right;"> 168-2326 </td>
   <td style="text-align:right;"> 853-1142 </td>
  </tr>
  <tr>
   <td style="text-align:right;"> 6 </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #dbf6e7">6</span> </td>
   <td style="text-align:right;"> <span style="display: block; padding: 0 4px; border-radius: 4px; background-color: #a7e0c0">6</span> </td>
   <td style="text-align:right;"> <span style="display: inline-block; direction: rtl; border-radius: 4px; padding-right: 2px; background-color: #FA614B; width: 100.00%">1.00000000</span> </td>
   <td style="text-align:right;"> 261-2807 </td>
   <td style="text-align:right;"> 1204-1827 </td>
  </tr>
</tbody>
</table>

<p>Finally, the selection of the sample is performed by using the same function selectSample, but this time is no more necessary to handle separately units to be sampled and units to be censused:</p>

<pre><code class="r">samp &lt;- selectSample(solution5$framenew,solution$aggr_strata)
#&gt; 
#&gt; *** Sample has been drawn successfully ***
#&gt;  34  units have been selected from  6  strata
#&gt; 
#&gt; ==&gt; There have been  2  take-all strata 
#&gt; from which have been selected  11 units
</code></pre>

<h1>Appendix - Methodological approach</h1>

<p>In a stratified sampling design with one or more stages, a sample is selected from a frame containing the units of the population of interest, stratified according to the values of one or more auxiliary variables (X) available for all units in the population.</p>

<p>For a given stratification, the overall size of the sample and the allocation in the different strata can be determined on the basis of constraints placed on the expected accuracy of the various estimates regarding the survey variables (Y).</p>

<p>If the target survey variables are more than one the optimization problem is said to be <em>multivariate</em>; otherwise it is <em>univariate</em>.</p>

<p>For a given stratification, in the univariate case the optimization of the allocation is in general based on the <em>Neyman allocation</em>. In the univariate case it is possible to make use of the <em>Bethel algorithm</em>.</p>

<p>The criteria according to which stratification is defined are crucial for the efficiency of the sample.</p>

<p>With the same precision constraints, the overall size of the sample required to satisfy them may be significantly affected by the particular stratification chosen for the population of interest.</p>

<p>Given G survey variables, their sampling variance is:</p>

<p>\[Var(\hat{Y_{g}})=\sum_{h=1}^{H}N_{h}^{2} (1- \frac{ 
  n_{h}}
  {N_{h}}) \frac{ 
  S_{h,g}^{2}}
  {n_{h}} \;\;\;  g=1,&hellip;,G\] </p>

<p>If we introduce the following cost function:</p>

<p>\[C(n_{1},&hellip;,n_{H})=C_{0}+\sum_{h=1}^{H}C_{h}n_{h} \]</p>

<p>the optimization problem can be formalized in this way:</p>

<p>\[min= C_{0}+\sum_{h=1}^{H}C_{h}n_{h}\ \]
under the constraints
\[ 
\begin{cases} 
CV(\hat{Y_{1}}) < U_{1}\\ 
CV(\hat{Y_{2}}) < U_{2}\\
...\\
CV(\hat{Y_{G}}) < U_{G}\\
\end{cases}
\]
where
\[ CV(\hat{Y_{g}}) = \frac{\sqrt{Var(\hat{Y_{g}})} } {mean(\hat{Y_{g}})}\]</p>

<p>Given a population frame with m auxiliary variables 
\(X_{1},&hellip;, X_{M}\) 
we define as <em>atomic stratification</em> 
the one that can be obtained considering the cartesian product of the definition domains of the m variables.
\[L=\{(l_{1}),(l_{2}),&hellip;,(l_{k})\}\]
Starting from the atomic stratification, it is possible to generate all the different stratifications that belong to the universe of stratifications. For example:</p>

<p>\[
\begin{align*}
&P_{1}=\{(l_{1},l_{2},l_{3})\} & P_{2}=\{(l_{1}),(l_{2},l_{3})\} \
&P_{2}=\{(l_{2}),(l_{1},l_{3})\} & P_{4}=\{(l_{31}),(l_{1},l_{2})\} \
&P_{5}=\{(l_{1}),(l_{2}),(l_{k})\}
\end{align*}
\]</p>

<p>The number of feasible stratifications  is exponential with respect to the number of initial atomic strata:</p>

<p>\[
\begin{align*}
& B_{4}=15 & B_{10}=115975 &
& B_{100}\approx 4.76 \times 10^{115} 
\end{align*}
\]</p>

<p>In concrete cases, it is therefore impossible to examine all the different possible alternative stratifications. 
The <em>Genetic Algorithm</em> allows to explore the universe of stratification in a very efficient way in order to find the optimal (or close to optimal) solution.</p>

<p>In planning a strafied sampling for a given survey, proceed as follows:</p>

<ul>
<li><p>given the survey variables \(Y_{1},Y_{2},&hellip;,Y_{p}\), set <em>precision constraints</em> on their estimates in the different domains, expressed in terms of CVs (coefficients of variation);</p></li>
<li><p>in the available sampling frame build the <em>atomic stratification</em>, obtained as cartesian product of the domains of the auxiliary variables \(X_{1},&hellip;,X_{M}\);</p></li>
<li><p>in each atomic stratum report the distributional characteristics of the survey variables by calculating their <em>means</em> and <em>standard deviations</em> calculate the values of the population (directly or by using proxy variables);</p></li>
<li><p>on the basis of these inputs, the Genetic Algorithm determines the <em>best solution</em> in terms of both frame <em>stratification</em>, <em>sample size</em> and <em>allocation</em> in optimized strata.</p></li>
</ul>

<p>The application of the genetic algorithm is based on the following steps:</p>

<ul>
<li><p>a given stratification is considered as an <em>individual</em> in a population (= <em>generation</em>) subject to <em>evolution</em>;</p></li>
<li><p>each individual is characterized by a <em>genome</em> represented by a vector of dimension equal to the number of atomic strata: the position of each element in the vector identifies an atomic stratum;</p></li>
<li><p>each element in the vector is assigned a random value between 1 and K (maximum acceptable number of  strata): the vector therefore indicates the way in which the individual atomic strata are aggregated together;</p></li>
<li><p>for each individual (stratification) its <em>fitness</em> is calculated by solving the corresponding problem of optimal allocation by means of Bethel&#39;s algorithm;</p></li>
<li><p>in passing from one generation to the next, <em>individuals with higher fitness are favored</em>;</p></li>
<li><p>at the end of the process of evolution, the individual with the overall best fitness represents the optimal solution.</p></li>
</ul>

<h1>References</h1>

</body>

</html>
